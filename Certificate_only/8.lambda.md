# AWS Lambda - Detailed Documentation

AWS Lambda is a serverless compute service that lets you run code without provisioning or managing servers. You simply upload your code, and Lambda takes care of everything required to run and scale it.

---

## Core Concepts

### 1. **Function**

* A Lambda **function** is the unit of deployment.
* Includes the **code** (inline, zip file, or container image), **runtime**, and **configuration** (timeout, memory, environment variables, etc.).

### 2. **Runtime**

* Prebuilt AWS Lambda runtimes (e.g., Python, Node.js, Java, Go, .NET, Ruby).
* You can also create **custom runtimes**.

### 3. **Handler**

* Entry point of your code (e.g., `index.handler` in Node.js or `lambda_function.lambda_handler` in Python).

### 4. **Execution Role (IAM Role)**

* Lambda functions run with **permissions** defined in an associated **IAM role**.
* This allows access to other AWS services (e.g., S3, DynamoDB, CloudWatch).

---

## Event Sources (Triggers)

Lambda is invoked in response to **events** from various AWS services:

| Service           | Example Trigger            |
| ----------------- | -------------------------- |
| API Gateway       | HTTP requests              |
| S3                | Object creation            |
| DynamoDB          | Stream events              |
| EventBridge       | Scheduled or custom events |
| SNS/SQS           | Message processing         |
| CloudWatch Events | Scheduled cron jobs        |

---

## Lambda Lifecycle

1. **Upload/Deploy** the function code.
2. Lambda creates an **execution environment** (sandboxed container).
3. On invocation:

   * Checks for existing warm container (cold start if not).
   * Initializes runtime, loads handler, executes function.
4. Returns result and logs to **CloudWatch Logs**.

---

## Configuration Options

| Configuration         | Description                                      |
| --------------------- | ------------------------------------------------ |
| Memory                | 128 MB to 10,240 MB (affects CPU proportionally) |
| Timeout               | 1 sec to 15 mins                                 |
| Environment Variables | Key-value pairs for config/secrets               |
| Concurrency           | Reserve/limit number of concurrent invocations   |
| VPC Access            | Attach Lambda to VPC (subnets + security groups) |

---

## Lambda Scaling

* Lambda **automatically scales** with the number of incoming events.
* Can handle **thousands of requests per second**.
* You can configure **Reserved Concurrency** to cap usage.

---

## Logging and Monitoring

* **CloudWatch Logs**: All output is captured and can be viewed in logs.
* **CloudWatch Metrics**: Invocations, Duration, Errors, Throttles.
* **X-Ray**: Tracing and debugging performance issues.

---

## Security

* **IAM Permissions** for execution role.
* Environment variables can be encrypted using **KMS**.
* **VPC integration** for private resources.
* Supports **resource-based policies** for trigger sources.

---

## Packaging Options

1. **Inline Editor** (console)
2. **ZIP file upload** (via Console, CLI, or SDK)
3. **S3 bucket** (reference ZIP)
4. **Container Image** (Docker image, up to 10 GB)

---

## Use Cases

* REST APIs / Webhooks
* File processing (S3 trigger)
* Real-time stream processing (DynamoDB, Kinesis)
* Automation and scheduled tasks (cron jobs)
* IoT backends



# AWS Lambda(upto next) - Detailed Documentation

AWS Lambda is a serverless compute service that lets you run code without provisioning or managing servers. You simply upload your code, and Lambda takes care of everything required to run and scale it.


## Core Concepts

### 1. **Function**

* A Lambda **function** is the unit of deployment.
* Includes the **code** (inline, zip file, or container image), **runtime**, and **configuration** (timeout, memory, environment variables, etc.).

### 2. **Runtime**

* Prebuilt AWS Lambda runtimes (e.g., Python, Node.js, Java, Go, .NET, Ruby).
* You can also create **custom runtimes**.

### 3. **Handler**

* Entry point of your code.

  * **Node.js**: `index.handler` (file: index.js, function: handler)
  * **Python**: `lambda_function.lambda_handler` (file: lambda\_function.py, function: lambda\_handler)
  * **Java**: Fully qualified class name implementing `RequestHandler`

  **Example (Node.js):**

  ```js
  exports.handler = async (event) => {
      return {
          statusCode: 200,
          body: JSON.stringify({ message: "Hello from Lambda!" })
      };
  };
  ```

  **Example (Python):**

  ```python
  def lambda_handler(event, context):
      return {
          'statusCode': 200,
          'body': 'Hello from Lambda!'
      }
  ```

### 4. **Execution Role (IAM Role)**

* Lambda functions run with **permissions** defined in an associated **IAM role**.
* This allows access to other AWS services (e.g., S3, DynamoDB, CloudWatch).

  **Example IAM Policy:**

  ```json
  {
    "Version": "2012-10-17",
    "Statement": [
      {
        "Effect": "Allow",
        "Action": ["s3:GetObject"],
        "Resource": "arn:aws:s3:::example-bucket/*"
      }
    ]
  }
  ```

---

## Event Sources (Triggers)

Lambda is invoked in response to **events** from various AWS services:

| Service           | Example Trigger            |
| ----------------- | -------------------------- |
| API Gateway       | HTTP requests              |
| S3                | Object creation            |
| DynamoDB          | Stream events              |
| EventBridge       | Scheduled or custom events |
| SNS/SQS           | Message processing         |
| CloudWatch Events | Scheduled cron jobs        |

**Example: S3 Trigger**

```json
{
  "Records": [
    {
      "s3": {
        "bucket": {
          "name": "example-bucket"
        },
        "object": {
          "key": "file.txt"
        }
      }
    }
  ]
}
```

---

## Lambda Lifecycle

```plaintext
+----------------------+
| 1. Deploy Function   |
+----------+-----------+
           |
           v
+----------+-----------+
| 2. Create Execution  |
|    Environment       |
+----------+-----------+
           |
           v
+----------+-----------+
| 3. Invoke Function   |
| - Load Handler       |
| - Execute Code       |
+----------+-----------+
           |
           v
+----------+-----------+
| 4. Return Result     |
|    + Log to CW Logs  |
+----------------------+
```

* Cold Start: New container creation, init runtime + handler (slower)
* Warm Start: Reuse existing environment (faster)

---

## Configuration Options

| Configuration         | Description                                      |
| --------------------- | ------------------------------------------------ |
| Memory                | 128 MB to 10,240 MB (affects CPU proportionally) |
| Timeout               | 1 sec to 15 mins                                 |
| Environment Variables | Key-value pairs for config/secrets               |
| Concurrency           | Reserve/limit number of concurrent invocations   |
| VPC Access            | Attach Lambda to VPC (subnets + security groups) |

---

## Lambda Scaling

Lambda automatically scales horizontally based on the rate of incoming requests:

### Key Aspects

* **No pre-scaling** required.
* AWS Lambda can handle **thousands of concurrent executions**.
* Scaling is based on event sources:

  * **API Gateway**: Scales with incoming HTTP requests.
  * **SQS**: Scales with number of messages.
  * **DynamoDB Streams/Kinesis**: Scales based on shard count.

### Concurrency Types

* **Unreserved Concurrency**: Default, shared with all functions.
* **Reserved Concurrency**: Guaranteed limit for a function.
* **Provisioned Concurrency**:

  * Keeps functions initialized (warm).
  * Useful for low-latency apps (no cold start).

### Throttling

* Happens when concurrency limit is exceeded.
* Results in 429 errors.

### Regional Limits (Default)

* 1,000 concurrent executions per region (can be increased).

---

## Logging and Monitoring

* **CloudWatch Logs**: All output is captured and can be viewed in logs.
* **CloudWatch Metrics**: Invocations, Duration, Errors, Throttles.
* **X-Ray**: Tracing and debugging performance issues.

---

## Security

* **IAM Permissions** for execution role.
* Environment variables can be encrypted using **KMS**.
* **VPC integration** for private resources.
* Supports **resource-based policies** for trigger sources.

---

## Packaging Options

1. **Inline Editor** (console)
2. **ZIP file upload** (via Console, CLI, or SDK)
3. **S3 bucket** (reference ZIP)
4. **Container Image** (Docker image, up to 10 GB)

---

## Use Cases

* REST APIs / Webhooks
* File processing (S3 trigger)
* Real-time stream processing (DynamoDB, Kinesis)
* Automation and scheduled tasks (cron jobs)
* IoT backends



## 🚀 **Key Use Cases of AWS Lambda in DevOps**

### 1. **Automated Infrastructure Tasks (IaC Support)**

* **Trigger-based automation** for CloudFormation, Terraform, or CDK workflows.
* Example:

  * When an S3 bucket is updated, a Lambda function auto-applies a CloudFormation stack update.
* **EventBridge + Lambda** can glue together IaC events.

---

### 2. **Serverless CI/CD Workflows**

* Build **event-driven CI/CD pipelines**.
* Examples:

  * Run custom validation logic when a code repo is updated (e.g., from CodeCommit or GitHub).
  * Integrate Lambda with **CodePipeline** for testing, deploying, tagging.

---

### 3. **S3 Automation**

* Automatically compress, move, or scan files uploaded to S3.
* Example:

  ```python
  def lambda_handler(event, context):
      bucket = event['Records'][0]['s3']['bucket']['name']
      key = event['Records'][0]['s3']['object']['key']
      # Logic: Scan file, compress, tag or move it
  ```

---

### 4. **Security & Compliance Automation**

* Auto-remediate non-compliant resources (e.g., open security groups).
* Integrate with **AWS Config** rules + Lambda for real-time remediation.
* Detect unused IAM roles, expired certs, and fix automatically.

---

### 5. **AWS Cost Optimization**

* Schedule start/stop of EC2/RDS for dev environments.
* Remove unattached EBS volumes or unused snapshots automatically.
* Analyze billing data and send reports.

---

### 6. **Log Processing & Alerting**

* Parse and analyze **CloudWatch Logs**, **VPC Flow Logs**, or **GuardDuty** findings.
* Trigger alerts or enrich log data into other systems like Elasticsearch, Slack, or Datadog.

---

### 7. **Monitoring & Metrics Collection**

* Custom metrics ingestion for **CloudWatch** (like queue length, 3rd party API latency).
* Process logs in real-time and push alerts if thresholds exceed.
* Integrate with Prometheus exporters.

---

### 8. **Scaling and Load Management**

* Use Lambda to auto-scale ECS services, manage Karpenter provisioners, or scale SQS workers.
* Example: Increase ECS task count when queue length > 1000.

---

### 9. **GitOps and Repo Automation**

* Monitor Git repositories (CodeCommit, GitHub) and trigger:

  * YAML validation
  * Policy enforcement
  * Auto-merging PRs or tagging

---

### 10. **Slack/Discord Bots for Ops**

* Create chat-based bots for real-time alerts or on-demand triggers.
* Use Slack buttons to trigger Lambda which:

  * Deploys a service
  * Retrieves logs
  * Restarts a pod

---

### 11. **Scheduled Jobs / Cron Replacement**

* Use EventBridge (CloudWatch Events) + Lambda to run periodic jobs:

  * Cleanup tasks
  * Report generation
  * Cost analysis

---

### 12. **Dynamic DNS or Configuration Management**

* Detect IP changes and update Route 53.
* Modify config files stored in S3 or Secrets Manager in real-time.

---

### 13. **EKS/Kubernetes Automation**

* Lambda can be used with:

  * **Webhook to Argo CD** for auto-sync
  * **K8s event triggers** via CloudTrail or custom webhook
  * Rotate secrets dynamically using IRSA + Lambda

---

### 14. **Real-Time Notifications**

* Push alerts to Slack, Teams, PagerDuty, or email based on:

  * CloudWatch Alarms
  * CodePipeline failures
  * Unauthorized access attempts

---

## 📌 Summary Table

| Category              | Lambda Use Case Example                              |
| --------------------- | ---------------------------------------------------- |
| **Infrastructure**    | Auto-tagging, resource cleanup, IaC automation       |
| **CI/CD**             | Custom test hooks, Git triggers, CodePipeline step   |
| **Monitoring**        | Log parsing, custom metric push, anomaly detection   |
| **Security**          | GuardDuty response, IAM cleanup, KMS key rotation    |
| **Cost Optimization** | Auto stop/start EC2, unused resource deletion        |
| **Communication**     | Slack bot, email/SMS alert push                      |
| **Scheduled Ops**     | Daily health checks, reports, backups                |
| **EKS Ops**           | Event-based deploys, restart pods, sync Helm/Argo CD |




## ✅ Example 1: **Auto-Delete Unused EBS Volumes (Cost Optimization)**

Deletes unattached EBS volumes (can be scheduled via EventBridge rule).

```python
import boto3

ec2 = boto3.client('ec2')

def lambda_handler(event, context):
    volumes = ec2.describe_volumes(
        Filters=[{'Name': 'status', 'Values': ['available']}]
    )['Volumes']

    deleted = []
    for vol in volumes:
        vol_id = vol['VolumeId']
        ec2.delete_volume(VolumeId=vol_id)
        deleted.append(vol_id)

    return {
        'statusCode': 200,
        'body': f'Deleted volumes: {deleted}'
    }
```

---

## ✅ Example 2: **Send Slack Notification on EC2 Stop Event (Monitoring + Alerting)**

Triggered by EventBridge when an EC2 instance is stopped.

```python
import json
import urllib3

SLACK_WEBHOOK_URL = "https://hooks.slack.com/services/XXX/YYY/ZZZ"
http = urllib3.PoolManager()

def lambda_handler(event, context):
    detail = event['detail']
    instance_id = detail['instance-id']
    state = detail['state']
    
    msg = {
        "text": f"⚠️ EC2 instance `{instance_id}` changed state to `{state}`"
    }
    encoded_msg = json.dumps(msg).encode('utf-8')
    http.request('POST', SLACK_WEBHOOK_URL, body=encoded_msg)

    return {'status': 'Notification sent'}
```

---

## ✅ Example 3: **Scan New S3 Uploads (Security / Processing)**

Triggered by S3 `PUT` events to auto-process a new file (e.g., virus scan, tagging, moving).

```python
import boto3

s3 = boto3.client('s3')

def lambda_handler(event, context):
    for record in event['Records']:
        bucket = record['s3']['bucket']['name']
        key = record['s3']['object']['key']

        # Just logging for now
        print(f"New file uploaded: s3://{bucket}/{key}")

        # Optional: Tag, move, or process file here
```

---

## ✅ Example 4: **Auto-Start EC2 Instance Based on Schedule (EventBridge)**

This can be scheduled using EventBridge rule (e.g., 8 AM daily).

```python
import boto3

ec2 = boto3.client('ec2')
INSTANCE_ID = 'i-xxxxxxxxxxxxxxx'

def lambda_handler(event, context):
    ec2.start_instances(InstanceIds=[INSTANCE_ID])
    return {'status': 'Started instance'}
```

---

## ✅ Example 5: **Auto-Tag New EC2 Instances (Resource Tagging Automation)**

Triggered by CloudTrail CreateInstance event.

```python
import boto3

ec2 = boto3.client('ec2')

def lambda_handler(event, context):
    instance_id = event['detail']['responseElements']['instancesSet']['items'][0]['instanceId']
    
    ec2.create_tags(
        Resources=[instance_id],
        Tags=[
            {'Key': 'Environment', 'Value': 'Dev'},
            {'Key': 'Owner', 'Value': 'DevOps Team'}
        ]
    )
    
    return {'status': f'Tagged instance {instance_id}'}
```

---

## ✅ Example 6: **Restart a Kubernetes Pod via AWS Lambda using boto3 (EKS Automation)**

Requires IRSA setup with permissions to call `eks` and run kubectl in the pod.

```python
import boto3
import subprocess

def lambda_handler(event, context):
    cluster_name = "your-cluster"
    pod_name = "your-pod"
    namespace = "your-namespace"
    
    # Update kubeconfig (if you're using EKS Authenticator within Lambda layer or docker image)
    subprocess.run(["aws", "eks", "update-kubeconfig", "--name", cluster_name])
    
    # Restart pod
    subprocess.run(["kubectl", "delete", "pod", pod_name, "-n", namespace])
    return {"status": "Pod restarted"}
```

> 🔒 Note: This is better run from a Lambda **container image** with `kubectl` and `aws` CLI pre-installed.

