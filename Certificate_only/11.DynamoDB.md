# Amazon DynamoDB - Deep Dive

## üîç What is Amazon DynamoDB?

Amazon DynamoDB is a fully managed NoSQL database service offered by AWS that provides fast and predictable performance with seamless scalability. It supports both **key-value** and **document-based** data models.

---

## ü§ñ Key Characteristics

* **Fully Managed**: No server provisioning or OS-level maintenance.
* **Single-digit millisecond latency**
* **Auto Scaling**: Adjusts capacity automatically
* **Multi-Region Replication** (Global Tables)
* **Event-Driven**: Integrated with DynamoDB Streams & Lambda
* **Built-in Security**: IAM, encryption, VPC endpoints
* **Highly Available and Durable**

---

## üìä Data Model Basics

### üîπ Table

* Container for data (similar to a table in RDBMS)

### üîπ Item

* A single row of data (can have varying attributes)

### üîπ Attributes

* Individual fields/columns in an item

### üîπ Primary Key

* Defines uniqueness of an item.
* **Partition key** (hash key) OR
* **Partition + Sort key** (composite key)

### üîπ Secondary Indexes

* **Global Secondary Index (GSI)**: Different partition/sort key
* **Local Secondary Index (LSI)**: Same partition key, different sort key

---

## üîß Core Features

### 1. **Provisioned vs On-Demand Capacity**

* **Provisioned Capacity**: You specify RCUs (Read Capacity Units) and WCUs (Write Capacity Units). Suitable for predictable workloads.
* **On-Demand Capacity**: No need to specify capacity. Scales automatically. Charges per request. Ideal for unpredictable or new applications.

### 2. **DynamoDB Streams**

* Captures item-level changes in a table (create, update, delete)
* Retains for 24 hours
* Can be used with AWS Lambda to trigger workflows
* Enables Change Data Capture (CDC) patterns

### 3. **Time to Live (TTL)**

* Enables automatic deletion of expired items
* Helps reduce storage costs
* Set by specifying a TTL attribute with a Unix timestamp

### 4. **Transactions**

* Ensures ACID properties
* Supports coordinated, all-or-nothing operations across one or more tables
* APIs: `TransactWriteItems`, `TransactGetItems`

### 5. **Global Tables**

* Multi-region, fully replicated tables
* Active-active replication
* Conflict resolution handled automatically by DynamoDB
* Low-latency access across geographies

### 6. **Backup and Restore**

* **On-Demand Backup**: Manual snapshot at any time
* **Point-in-Time Recovery (PITR)**: Automatically enabled backup that lets you restore any point in the past 35 days

---

## üîê Security

### üî∏ Encryption at Rest using AWS KMS

* DynamoDB encrypts all data using AWS Key Management Service (KMS)
* Supports AWS-managed or customer-managed keys

### üî∏ VPC Endpoints for Private Access

* Use AWS PrivateLink to create interface VPC endpoints
* Access DynamoDB securely without traversing the public internet

### üî∏ IAM Policies for Fine-Grained Access Control

* Control who can access which items/attributes
* IAM policies can specify conditions based on partition key values

### üî∏ CloudTrail for Audit Logging

* All DynamoDB operations are recorded by AWS CloudTrail
* Useful for auditing and security analysis

---

## üåä Performance & Scaling

* **Partitioning**: Data is partitioned by partition key
* **DAX (DynamoDB Accelerator)**: In-memory cache with microsecond latency
* **Adaptive Capacity**: Automatically redistributes capacity based on load
* **Best Practice**: Choose high-cardinality partition keys

---

## üéì Example Use Cases

* Real-time analytics
* IoT data ingestion
* User sessions and profiles
* Leaderboards and gaming data
* Shopping carts & order tracking
* Event-driven microservices

---

## ‚úÖ Best Practices Checklist

* [ ] Choose partition keys carefully to avoid hotspots
* [ ] Use On-Demand for unpredictable workloads
* [ ] Use TTL to clean up stale data
* [ ] Leverage DAX for caching frequent reads
* [ ] Monitor using CloudWatch metrics
* [ ] Secure with IAM roles and KMS encryption
* [ ] Use Streams with Lambda for reactive processing
* [ ] Enable PITR for critical tables

---

## üìÅ Sample Table Structure

```json
{
  "UserId": "user123",   // Partition Key
  "OrderId": "ord789",   // Sort Key (optional)
  "Name": "Alice",
  "Email": "alice@example.com",
  "CreatedAt": "2025-08-07T12:00:00Z"
}
```

# Amazon DynamoDB - Core Concepts

## üìò Overview

Amazon DynamoDB is a fully managed NoSQL database service offered by AWS. It provides fast and predictable performance with seamless scalability.

---

## üß± Core Concepts

### 1. **Table**

* A table is a collection of data in DynamoDB.
* It stores multiple **items** (akin to rows in relational databases).
* You must define a **Primary Key** when creating a table.
* Example: A table named `Users` could store information like user ID, name, and email.

```bash
Table Name: Users
```

---

### 2. **Item**

* An item is a single data record in a table.
* It is similar to a row in a traditional database.
* Each item is uniquely identified by a **Primary Key**.
* Items are schema-less, allowing each item to have a different set of attributes.

```json
{
  "UserID": "12345",
  "Name": "Reetesh Kumar",
  "Email": "reetesh@example.com",
  "Age": 28
}
```

---

### 3. **Attributes**

* Attributes are key-value pairs associated with an item.
* Types include:

  * String
  * Number
  * Binary
  * Boolean
  * Null
  * List
  * Map
* Example:

```json
{
  "UserID": "12345",  // Partition key
  "Email": "reetesh@example.com", // Attribute
  "Preferences": {
    "Language": "English",
    "DarkMode": true
  }
}
```

---

### 4. **Primary Key**

Defines how items in a table are uniquely identified.

* **Partition Key (Hash Key):** A single attribute. DynamoDB uses it to determine item placement and hash partitioning.
* **Partition Key + Sort Key (Composite Key):** Supports querying multiple items with the same partition key but different sort keys.

#### Examples:

* **Partition Key only:**

```json
"UserID": "12345"
```

* **Partition Key + Sort Key:**

```json
"UserID": "12345",
"OrderDate": "2025-08-07"
```

---

### 5. **Secondary Indexes**

Allows querying the table using non-primary key attributes.

#### a. **Global Secondary Index (GSI):**

* Can use any attribute(s) as partition and sort key.
* Supports eventual consistency.
* Created during or after table creation.

#### b. **Local Secondary Index (LSI):**

* Shares the same Partition Key as the base table but allows a different Sort Key.
* Must be defined during table creation.

#### Example GSI:

```bash
GSI Name: EmailIndex
Partition Key: Email
```

Query example:

```bash
Query Users where Email = 'reetesh@example.com'
```

# Amazon DynamoDB - Performance, Best Practices & Use Cases

## üöÄ Performance & Scaling

### üîπ Partitioning

* DynamoDB partitions your table data using the **partition key**.
* Items with the same partition key go to the same partition.
* To scale efficiently, use **high-cardinality partition keys** to avoid hotspots.

### üîπ Adaptive Capacity

* Automatically adjusts capacity allocation based on traffic patterns.
* Helps manage uneven workloads without manual intervention.

### üîπ DynamoDB Accelerator (DAX)

* Fully managed in-memory caching layer for DynamoDB.
* Reduces read latency from milliseconds to microseconds.
* Ideal for read-heavy and low-latency applications.

### üîπ Auto Scaling

* Adjusts read/write capacity based on actual usage.
* Works with provisioned mode.

### üîπ On-Demand Mode

* Automatically handles traffic peaks and troughs.
* Suitable for unpredictable workloads.

### üîπ Write Sharding

* For write-heavy workloads on same partition key, use a sharding pattern (e.g., `user#1`, `user#2`) to distribute writes.

### üîπ Batch Operations

* Use `BatchGetItem` and `BatchWriteItem` for efficient operations across multiple items.

---

## ‚úÖ Best Practices Checklist

* [x] Design partition keys to ensure even data distribution
* [x] Avoid hot partitions (e.g., single partition key with heavy access)
* [x] Enable TTL to automatically delete expired items
* [x] Use DAX for high-performance caching
* [x] Monitor capacity and throttles via CloudWatch
* [x] Leverage DynamoDB Streams for real-time processing
* [x] Use Global Tables for multi-region availability
* [x] Secure data using IAM, VPC Endpoints, and KMS encryption
* [x] Enable Point-in-Time Recovery (PITR) for critical tables
* [x] Use GSIs and LSIs strategically for flexible queries

---

## üíº Example Use Cases

### 1. Real-Time Analytics

* Capture and process clickstream or event data in near real time
* Combine with Lambda and Streams to push data into Redshift or S3

### 2. IoT Data Ingestion

* Store data from millions of devices with high write throughput
* TTL can be used to auto-expire old sensor data

### 3. User Sessions and Profiles

* Store user login sessions, preferences, and activity logs
* Fast read/write for web/mobile applications

### 4. Leaderboards and Gaming Data

* Maintain scores, match history, and player statistics
* Sort key enables time-based or score-based rankings

### 5. Shopping Carts & Order Tracking

* Track cart state, item availability, and order lifecycle
* Global Tables allow e-commerce systems to serve global customers

### 6. Event-Driven Microservices

* Use Streams to trigger Lambda on table changes
* Supports loosely coupled architecture for scalability


------



## üí∏ Cost Optimization Strategies

* Start with On-Demand, switch to Provisioned when traffic is predictable

* Enable TTL to remove old data and reduce storage costs

* Use DAX for heavy-read workloads to reduce read unit costs

* Avoid over-provisioning indexes (especially GSIs)

* Use short-lived backups or archive periodically to S3

* Use CloudWatch alarms to track underutilization

* Use reserved capacity for long-term predictable workloads

* Store large blobs or media in S3, and only metadata in DynamoDB

## üéì Example Use Cases

* Real-time analytics: High-speed writes & reads (with TTL + Streams)

* IoT data ingestion: Millions of device updates per second

* User sessions and profiles: Fast access to user data

* Leaderboards and gaming data: Sorted access with sort key

* Shopping carts & order tracking: Time-based sort keys per user

* Event-driven microservices: Using Streams + L
