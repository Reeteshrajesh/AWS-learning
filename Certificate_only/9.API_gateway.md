# AWS API Gateway - Core Concepts (DevOps-Focused)

## Overview

Amazon API Gateway is a fully managed service that allows developers to create, publish, maintain, monitor, and secure APIs at any scale. It acts as a "front door" for applications to access data, business logic, or functionality from your backend services (e.g., Lambda, EC2, HTTP, VPC).

---

## 1. **REST API vs HTTP API vs WebSocket API**

| Feature            | REST API                            | HTTP API                    | WebSocket API                         |
| ------------------ | ----------------------------------- | --------------------------- | ------------------------------------- |
| Best For           | Full-featured API with fine control | Simpler, lower-latency APIs | Real-time bidirectional communication |
| Lambda Integration | ‚úÖ Yes                               | ‚úÖ Yes                       | ‚úÖ Yes                               |
| AWS Service Proxy  | ‚úÖ Yes                               | ‚ùå No                        | ‚ùå No                                |
| OpenAPI Support    | ‚úÖ Full                              | ‚úÖ Limited                   | ‚ùå                                   |
| Authentication     | ‚úÖ Cognito, IAM, Custom              | ‚úÖ JWT, IAM                  | IAM                                  |
| Cost               | Higher                              | Lower                       | Depends                               |

---

## 2. **Core Components**

### a. **Resources**

* Define the URL structure (e.g., `/users`, `/orders`)
* Each resource can have methods like GET, POST, DELETE, etc.

### b. **Methods**

* HTTP verbs associated with each resource (GET, POST, etc.)
* Can be integrated with:

  * AWS Lambda
  * HTTP backends
  * AWS services (via AWS Service Proxy)

### c. **Stages**

* Different environments (e.g., `dev`, `prod`, `qa`)
* Each stage has its own URL endpoint
* Support for stage variables (e.g., version, Lambda alias)

### d. **Integrations**

* Type of backend connected to the method:

  * **Lambda Integration** (most common for serverless)
  * **HTTP Integration** (external endpoints)
  * **AWS Service Proxy** (e.g., S3, SNS, DynamoDB)

### e. **Mappings**

* Request Mapping:

  * Modify/transform incoming request data before passing to backend
  * Useful for input validation, header rewriting

* Response Mapping:

  * Modify backend response before sending it to the client
  * Customize error messages, format conversions

---

## 3. **Security & Access Control**

### a. **Authorization Types**

* **IAM-based**: Secure internal APIs with AWS IAM roles and policies
* **Cognito User Pools**: Built-in authentication for user-based auth
* **Lambda Authorizers**: Custom logic (JWT, OAuth2, etc.)
* **API Keys**: Throttle/track API usage per client

### b. **Throttling & Quotas**

* Control abuse and ensure fair use
* Configurable per API stage and per API key

### c. **Resource Policies**

* Define who can invoke your APIs (like S3 bucket policies)
* Example: Allow requests from specific IP ranges

---

## 4. **Monitoring & Logging**

* **CloudWatch Metrics**:

  * 4xx, 5xx error count
  * Integration latency
  * Cache hit/miss ratio

* **CloudWatch Logs**:

  * Enable detailed execution logs
  * Useful for debugging integrations

* **X-Ray Tracing**:

  * Visualize API call flow (only for Lambda integrations)

---

## 5. **DevOps Use Cases**

* Secure access to internal Lambda-powered microservices
* Proxy API to on-prem or legacy services via VPC link
* Public APIs for mobile/web apps
* Webhook receiver with transformation logic
* CI/CD deployments per stage using tools like CodePipeline

---

## 6. **Diagram: API Gateway Request Flow**

```
Client ---> API Gateway ---> [Authorization] ---> [Throttling/Quota] ---> [Integration: Lambda/HTTP] ---> Response Mapping ---> Client
```

# üß† **AWS API Gateway ‚Äì Advanced Concepts & Deep Dive**

---

## üìå 1. **Deployment Lifecycle**

API Gateway follows a structured lifecycle for managing your APIs:

### a. **Development**

* Define resources, methods, integrations, mappings, and security.
* Use OpenAPI (Swagger) for specification-driven development.

### b. **Deployment**

* Changes must be deployed to a **stage** (e.g., `/prod`, `/dev`).
* Each stage is versioned and can be mapped to different Lambda aliases.

### c. **Stage Variables**

* Key-value pairs accessible in integration configurations.
* Example use: switch between `v1` and `v2` Lambda versions dynamically.

---

## üì¶ 2. **Caching**

API Gateway supports **response caching** for better performance and cost-efficiency.

### üîπ Features:

* Available for REST APIs (not HTTP APIs).
* Configurable per method.
* Reduces load on backend services.
* TTL can be set (e.g., 5 seconds to 1 hour).

### üîπ Use Case:

```yaml
GET /products ‚Üí cache TTL: 60s
```

‚Üí Useful for high-volume read APIs like product catalog, configurations, or public content.

---

## üîå 3. **Integration Types (Advanced)**

| Integration Type      | Use Case Example                       | Notes                    |
| --------------------- | -------------------------------------- | ------------------------ |
| **Lambda**            | Serverless backends                    | Most common              |
| **HTTP/HTTPS**        | External APIs (e.g., third-party SaaS) | Secure using VPC Link    |
| **AWS Service Proxy** | Directly invoke AWS services (S3, SNS) | No need for Lambda       |
| **Mock Integration**  | Simulate response without backend      | For testing & dummy APIs |
| **VPC Link**          | Connect to private resources in VPC    | Load balancer required   |

---

## üîí 4. **Security in Depth**

### a. **WAF Integration**

* Protect APIs against common threats (SQLi, XSS, etc.)
* Rate limiting and bot control
* Attach WAF ACLs to your API Gateway stages

### b. **CORS (Cross-Origin Resource Sharing)**

* Must be explicitly enabled per method for browser access
* API Gateway automatically adds CORS headers if configured

### c. **TLS/SSL**

* Custom domain names can be attached with ACM certificates
* Supports TLS 1.2+

---

## üìà 5. **Monitoring and Observability**

### a. **Metrics (CloudWatch)**

| Metric          | Description                        |
| --------------- | ---------------------------------- |
| `4XXError`      | Client errors (bad requests, auth) |
| `5XXError`      | Backend/integration failures       |
| `Latency`       | Time from request to response      |
| `CacheHitCount` | Number of cached responses         |

### b. **Logs**

* Enable execution logging per stage
* Capture request/response payloads (beware of sensitive data)
* Filter logs using `@requestId` or custom context

### c. **X-Ray Tracing**

* View end-to-end request flow
* Use with Lambda for full tracing path

---

## üìä 6. **Cost Optimization Tips**

| Strategy                  | Benefit                                  |
| ------------------------- | ---------------------------------------- |
| Use **HTTP APIs**         | Cheaper for simpler workloads            |
| Enable **caching**        | Reduce backend invocations               |
| Disable **detailed logs** | Avoid unnecessary CloudWatch costs       |
| Set **throttling/quotas** | Prevent overuse from misbehaving clients |

---

## üìÅ 7. **Import/Export & Versioning**

* APIs can be defined via OpenAPI 3.0 specs
* Supports export to Swagger for documentation tools
* Versioning can be managed via:

  * Lambda aliases
  * Stage URLs
  * Stage variables

---

## üë®‚Äçüíª 8. **Developer Portal Integration**

* API Gateway provides an open-source **Developer Portal** to:

  * Share API documentation
  * Allow API consumers to sign up and use API Keys
  * Display Swagger/OpenAPI docs

---

## ‚öôÔ∏è 9. **CI/CD & Infrastructure as Code (IaC)**

### Tools:

* **AWS SAM** / Serverless Framework
* **Terraform**
* **CloudFormation**

### Example Terraform Resource:

```hcl
resource "aws_api_gateway_rest_api" "my_api" {
  name = "example-api"
}

resource "aws_api_gateway_resource" "my_resource" {
  rest_api_id = aws_api_gateway_rest_api.my_api.id
  parent_id   = aws_api_gateway_rest_api.my_api.root_resource_id
  path_part   = "status"
}

resource "aws_api_gateway_method" "my_method" {
  rest_api_id   = aws_api_gateway_rest_api.my_api.id
  resource_id   = aws_api_gateway_resource.my_resource.id
  http_method   = "GET"
  authorization = "NONE"
}
```

---

## üîÅ 10. **Real-time API Support: WebSocket APIs**

* Persistent, bidirectional communication
* Use cases: Chat apps, trading dashboards, gaming, IoT
* Uses **routes** instead of HTTP methods

---

## üìö Summary Table

| Feature            | REST API             | HTTP API | WebSocket API |
| ------------------ | -------------------- | -------- | ------------- |
| Lambda Integration | ‚úÖ                    | ‚úÖ        | ‚úÖ             |
| AWS Service Proxy  | ‚úÖ                    | ‚ùå        | ‚ùå             |
| Authorizers        | IAM, Cognito, Lambda | IAM, JWT | IAM           |
| OpenAPI Support    | ‚úÖ                    | ‚úÖ        | ‚ùå             |
| Caching            | ‚úÖ                    | ‚ùå        | ‚ùå             |
| Cost               | Higher               | Lower    | Moderate      |
| WebSocket Support  | ‚ùå                    | ‚ùå        | ‚úÖ             |

---

## üß∞ DevOps-Specific Use Cases

* **Centralized Gateway for Microservices**
* **Environment Isolation via Stages (`/dev`, `/prod`)**
* **CI/CD with auto-deploy**
* **Security Gateway for Private APIs (VPC Link + Lambda)**
* **API Usage Plans and Rate-Limiting**
* **Custom Domains with HTTPS termination**


## ‚úÖ **API Gateway Best Practices Checklist (DevOps-Oriented)**

### 1. **Security**

* [ ] Enable **authorization**: use IAM, Cognito, or Lambda Authorizer
* [ ] Use **resource policies** to restrict access by IP/VPC
* [ ] Enforce **TLS (HTTPS)** only
* [ ] Never expose internal APIs publicly unless required
* [ ] Use **API keys** for rate-limiting and client tracking
* [ ] Enable **WAF** for DDoS protection (if public-facing)

### 2. **Performance & Cost Optimization**

* [ ] Use **HTTP APIs** for simpler use cases (cheaper and faster)
* [ ] Enable **caching** at method or stage level to reduce backend load
* [ ] Set **appropriate throttling** (burst and rate limits)
* [ ] Choose **private integration** (VPC Link) for internal services

### 3. **Monitoring & Observability**

* [ ] Enable **CloudWatch Logs** for request/response and errors
* [ ] Monitor **4xx/5xx errors**, **latency**, **throttling** metrics
* [ ] Use **X-Ray tracing** for end-to-end observability
* [ ] Tag APIs with meaningful identifiers (team, environment, service)

### 4. **Deployments & CI/CD**

* [ ] Use **stage variables** for versioning and environment configs
* [ ] Automate deployments using **Terraform**, **CloudFormation**, or **AWS CDK**
* [ ] Version control OpenAPI specifications or IaC templates
* [ ] Roll out changes using **canary deployments** via stage deployment management

### 5. **Design & Structure**

* [ ] Design consistent resource paths (`/users/{id}`, `/orders/{id}`)
* [ ] Use appropriate **status codes** and response formats (JSON)
* [ ] Use **request/response mapping templates** for validation and formatting
* [ ] Document API with **OpenAPI / Swagger**

---

## üöÄ Small Application Example

### üí° Use Case

A simple backend that exposes a public HTTP endpoint `/hello` and returns a JSON message using AWS Lambda + API Gateway (HTTP API).

---

### 1. **Lambda Function** (Python)

**File: `lambda_function.py`**

```python
def lambda_handler(event, context):
    name = event.get("queryStringParameters", {}).get("name", "World")
    return {
        "statusCode": 200,
        "headers": {"Content-Type": "application/json"},
        "body": f'{{"message": "Hello, {name}!"}}'
    }
```

---

### 2. **Deploy with AWS CLI**

**Create Lambda**

```bash
zip function.zip lambda_function.py

aws lambda create-function \
  --function-name helloLambda \
  --runtime python3.11 \
  --handler lambda_function.lambda_handler \
  --role arn:aws:iam::<ACCOUNT_ID>:role/<LAMBDA_EXEC_ROLE> \
  --zip-file fileb://function.zip
```

---

### 3. **Create API Gateway HTTP API**

```bash
aws apigatewayv2 create-api \
  --name "HelloAPI" \
  --protocol-type HTTP \
  --target arn:aws:lambda:<REGION>:<ACCOUNT_ID>:function:helloLambda
```

AWS will automatically create an **integration** between API Gateway and the Lambda function.

---

### 4. **Add Permissions**

```bash
aws lambda add-permission \
  --function-name helloLambda \
  --statement-id apigateway-test \
  --action lambda:InvokeFunction \
  --principal apigateway.amazonaws.com \
  --source-arn "arn:aws:execute-api:<REGION>:<ACCOUNT_ID>:<API_ID>/*/*/*"
```

---

### 5. **Test Endpoint**

Call it using `curl` or browser:

```bash
curl "https://<API_ID>.execute-api.<REGION>.amazonaws.com/hello?name=Reetesh"
```

Response:

```json
{"message": "Hello, Reetesh!"}
```

---

## üß† How It Works

1. **Client** sends an HTTP request to API Gateway.
2. **API Gateway** invokes the **Lambda function** as the integration backend.
3. **Lambda** processes input and returns a JSON response.
4. **API Gateway** forwards the Lambda response to the client.


