# AWS Elastic Beanstalk – In-Depth Guide

## What is AWS Elastic Beanstalk?

**Elastic Beanstalk** is an AWS **Platform-as-a-Service (PaaS)** that allows you to deploy and manage applications without needing to manage the underlying infrastructure. You simply upload your code, and Beanstalk handles provisioning, load balancing, auto scaling, monitoring, and deployment.

It’s ideal for web applications and APIs developed in popular languages like Java, .NET, PHP, Node.js, Python, Ruby, Go, and Docker.

---

## Key Concepts

### Application

* A logical container for related environments and versions.
* E.g., an app called `myshop` may have multiple environments: `dev`, `staging`, `prod`.

### Environment

* An isolated deployment of your application.
* It includes EC2 instances, ELB, Auto Scaling Group, and RDS (optional).

### Application Version

* A specific version of your deployed application (usually a `.zip`, WAR, or Docker image).
* Stored in S3.

### Environment Configuration

* Saved settings such as instance type, scaling, VPC, logs, platform version, etc.

### Platform

* A pre-configured stack (e.g., Node.js on Amazon Linux 2).
* Managed by AWS and automatically patched.

---

## How It Works

```
1. You upload your code bundle (.zip, WAR, or Dockerfile).
2. Elastic Beanstalk provisions AWS resources (EC2, ELB, ASG, CloudWatch).
3. Your application is deployed and monitored.
4. You can update versions, scale, or change settings via console, CLI, or API.
```

---

## Architecture Overview

Elastic Beanstalk manages:

* **Amazon EC2** – for compute
* **Auto Scaling Group** – for automatic scaling
* **Elastic Load Balancer (ALB)** – for traffic distribution
* **Amazon RDS (optional)** – for database
* **Amazon S3** – for storing app versions
* **CloudWatch Logs** – for log management
* **IAM Roles** – for permissions

---

## Deployment Models

### Managed (default)

Elastic Beanstalk provisions everything including EC2, ELB, ASG, CloudWatch, etc.

### Custom VPC

You can deploy your Beanstalk environment into your own VPC and subnets for tighter control.

### Docker & Multicontainer Support

* Single-container Docker using a `Dockerfile`
* Multicontainer using **Docker Compose** with ECS integration

---

## Features

* **Zero-downtime deployments** (Rolling / Rolling with additional batch / Blue-Green)
* **Monitoring and Health Dashboard**
* **Built-in Logs & Metrics** (CPU, memory, latency, etc.)
* **Environment Cloning & Saved Configs**
* **Automated Backups with RDS**
* **Custom AMIs for EC2 if needed**

---

## Security

* Use **IAM roles** for EC2 and service access
* Encrypt RDS and log data at rest
* Integrate with **Secrets Manager** for managing sensitive credentials
* Deploy inside private subnets for isolation
* Integrate with **WAF**, **Shield**, and **CloudFront** for edge security

---

## Common Use Cases

| Use Case                     | Description                                  |
| ---------------------------- | -------------------------------------------- |
| Quick app deployment         | Deploy code without managing servers         |
| Staging/Testing environments | Spin up isolated testing environments easily |
| Multi-tier web apps          | App tier on EC2 + database tier on RDS       |
| Dockerized apps              | Run single or multi-container apps           |
| Blue-Green deployments       | Reduce downtime during version updates       |

---

## Best Practices

1. **Use versioning** – Keep multiple app versions for rollback.
2. **Separate environments** – Use `dev`, `staging`, and `prod` with isolation.
3. **Monitor health** – Set alarms on latency, CPU, and HTTP codes.
4. **Leverage rolling updates** – For zero-downtime deployments.
5. **Secure database separately** – Prefer RDS with backups and security groups.
6. **Use VPC and private subnets** – For better control and isolation.
7. **Automate with CI/CD** – Use CodePipeline + Beanstalk for seamless delivery.
8. **Use environment variables** – Avoid hardcoding sensitive data.
9. **Enable log streaming** – Forward logs to CloudWatch for visibility.
10. **Use lifecycle policies** – Automatically delete old app versions from S3.

---

## Example Workflow

```
git clone my-app
cd my-app
eb init -p node.js my-app
eb create staging-env
eb deploy
```

Or via the AWS Console:

* Upload → Configure → Launch → Monitor

---

## Notes

* Not ideal for microservices at scale (ECS/EKS is better suited)
* Still excellent for **monoliths**, **small teams**, and **fast deployment**
* Great fit for **startups** or **internal apps**



# AWS Elastic Beanstalk - Key Features (Explained)

Elastic Beanstalk is a Platform as a Service (PaaS) that allows developers to deploy and manage applications quickly without worrying about the infrastructure beneath. Below is a deep dive into its core features.

---

## Zero-Downtime Deployments

Elastic Beanstalk supports several deployment strategies that ensure your users experience little to no downtime during updates:

### 1. Rolling Deployments

* **How it works**: Updates a few instances at a time.
* **Benefit**: Minimizes impact on user traffic.
* **Trade-off**: Reduced capacity temporarily during deployment.

### 2. Rolling with Additional Batch

* **How it works**: Launches extra instances temporarily, updates in batches.
* **Benefit**: Maintains full capacity throughout the deployment.
* **Ideal For**: Production apps where no downtime is acceptable.

### 3. Blue-Green Deployments

* **How it works**: Deploys a new environment (green), shifts traffic from the old one (blue) when ready.
* **Benefit**: Safest method; instant rollback by switching traffic back.
* **Trade-off**: Doubles environment cost during deployment.

---

## Monitoring & Health Dashboard

Elastic Beanstalk provides a visual dashboard to monitor application health:

* **Real-time Health Status**: Green, Yellow, Red indicators.
* **Detailed Metrics**: CPU usage, latency, request count, error rate, etc.
* **Health Causes**: Shows potential reasons for degraded health.
* **Event Logs**: Timestamped actions (deployments, restarts, scaling events).

This helps in rapid troubleshooting and understanding infrastructure behavior over time.

---

## Built-in Logs & Metrics

Elastic Beanstalk integrates with Amazon CloudWatch and provides:

* **Instance Logs**: Web server, application, and system logs.
* **Custom Metrics**: Track memory, disk, or app-specific metrics.
* **Log Streaming**: Send logs directly to CloudWatch Logs.
* **Log Snapshot**: On-demand or scheduled log capture from all instances.

---

## Environment Cloning & Saved Configurations

### Environment Cloning:

* **Use Case**: Quickly replicate staging/production environments.
* **Benefits**:

  * Speed up testing of new changes.
  * No need to manually replicate settings or resources.

### Saved Configurations:

* **How it works**: Save current environment settings as a reusable template.
* **Use Case**: Create new environments consistently.
* **Example**: Save a configuration after tuning autoscaling rules, instance types, or software versions.

---

## Automated Backups with RDS

When your Elastic Beanstalk environment uses Amazon RDS:

* **Automated Snapshots**: Daily backups managed by AWS.
* **Retention Period**: Configurable; defaults to 7 days.
* **Point-in-Time Recovery**: Restore to any second within the backup window.
* **Decoupled RDS Option**: Keep DB outside the EB environment to avoid accidental deletion.

---

## Custom AMIs (Amazon Machine Images)

Elastic Beanstalk allows the use of custom EC2 AMIs:

* **Why Use Custom AMIs?**

  * Pre-installed software.
  * Hardened OS configurations.
  * Language runtimes or third-party tools not supported out-of-the-box.

* **How to Use**:

  * Create an AMI based on a Beanstalk-supported platform.
  * Modify EC2 launch configuration to use your AMI.

* **Use Case Examples**:

  * Compliance needs (CIS-hardened AMIs).
  * Pre-baked containers or web server configurations.


# Deployment Strategy Configuration in AWS Elastic Beanstalk

Elastic Beanstalk provides several deployment strategies to control **how updates are rolled out** to the EC2 instances in your environment. The strategy you choose affects **application availability, deployment speed, and downtime**.

---

## Deployment Policies

### 1. **All at Once (Default for single instance environments)**

* **How it works**: Deploys the new version to **all instances at once**.
* **Pros**:

  * Fastest deployment.
* **Cons**:

  * Causes **downtime**.
  * No rollback if deployment fails.

> Use Case: Dev/test environments where uptime is not critical.

---

### 2. **Rolling Deployment**

* **How it works**: Divides the environment into **batches**. Each batch is updated **sequentially**.

* During the update:

  * One batch is taken out of service.
  * Updated with the new version.
  * Brought back into service before moving to the next batch.

* **Pros**:

  * Minimizes downtime.
  * Reduces impact of a failed deployment.

* **Cons**:

  * If a batch fails, rollback might not be automatic.
  * Reduced capacity during deployment.

> Use Case: Environments with low to moderate traffic.

---

### 3. **Rolling with Additional Batch**

* **How it works**: Similar to rolling, but adds a **temporary extra batch** to maintain full capacity during deployment.

* **No instance is terminated** before the new version is fully up.

* **Pros**:

  * Maintains full capacity.
  * Safer than standard rolling.

* **Cons**:

  * Requires **extra EC2 instances**, which might incur costs.

> Use Case: Production environments needing **zero downtime** and high availability.

---

### 4. **Immutable Deployment**

* **How it works**: Deploys new version to **a full set of new EC2 instances** in a separate auto scaling group.

* If successful:

  * Old instances are terminated.

* If failed:

  * Rollback is easier.

* **Pros**:

  * **Zero downtime**.
  * Easy rollback.
  * Safer deployment.

* **Cons**:

  * More resource-intensive.
  * Slower than Rolling.

> Use Case: Mission-critical apps with strict uptime SLAs.

---

### 5. **Blue/Green Deployment**

* **How it works**:

  * Create a new **parallel environment** (Green).
  * Deploy new version to Green.
  * Test it thoroughly.
  * Swap DNS from **Blue (old)** to **Green (new)**.

* **Pros**:

  * **No risk to live traffic** during testing.
  * Full control over switchover.

* **Cons**:

  * Requires **manual effort** or automation scripting.
  * Duplicates infrastructure during deployment (higher cost).

> Use Case: Safe, pre-tested deployments in large-scale production.

---

## Where to Configure?

You can configure deployment strategies in:

* **Elastic Beanstalk Console**:

  * Go to **Configuration → Rolling updates and deployments**
* **`.ebextensions` or `configuration.yaml`** in your application code.
* **AWS CLI** or **Elastic Beanstalk API**.

---

## Best Practices

* Use **Immutable** or **Rolling with additional batch** for production environments.
* Always enable **health checks** and monitoring.
* Combine with **CI/CD tools (e.g., CodePipeline, Bitbucket Pipelines)** for automation.
* Use **Blue/Green** for highly sensitive apps and A/B testing.



## Elastic Beanstalk Architecture Overview

Elastic Beanstalk is a **Platform-as-a-Service (PaaS)** that abstracts infrastructure management and allows you to **deploy, manage, and scale web applications** quickly and easily.

---

### Key Components of the Architecture

| Component                     | Description                                                                                                                     |
| ----------------------------- | ------------------------------------------------------------------------------------------------------------------------------- |
| **Application**               | A logical container for all the Elastic Beanstalk components (environments, versions, configurations).                          |
| **Environment**               | A deployment of your application (e.g., dev, test, prod), consisting of resources like EC2 instances, ELB, Auto Scaling groups. |
| **Environment Tier**          | Two types: **Web Server** (HTTP) or **Worker** (background jobs, queues).                                                       |
| **Environment Configuration** | Settings like instance type, scaling limits, health checks, platform version.                                                   |
| **Application Version**       | A specific build or deployment of your application code.                                                                        |
| **Platform**                  | Preconfigured stack (e.g., Node.js, Java, Python, Docker) with OS, web server, language runtime.                                |
| **Managed Services**          | ELB, EC2, Auto Scaling, CloudWatch, RDS, S3 (used under the hood).                                                              |

---

## How It Works (High-Level Flow)

1. You **upload your app** (ZIP, WAR, or Docker image) to Elastic Beanstalk.
2. EB provisions infrastructure (EC2, ELB, Auto Scaling, etc.).
3. It **deploys the app** to EC2 instances.
4. Monitors app health via CloudWatch, sends alerts, and can perform **rolling deployments**.
5. Traffic is served via **Load Balancer**.
6. Logs and metrics are viewable via EB console or exported to S3/CloudWatch.

---

## Example Architecture: Web App Using Node.js + RDS

### Scenario: Deploying a Node.js-based blogging platform with a MySQL backend

### Setup:

* App is written in **Node.js**.
* Database is **Amazon RDS MySQL**.
* Uses **Elastic Beanstalk Web Tier**.
* Hosted on **multi-AZ** environment for HA.

### Components:

| Resource                        | Details                                                |
| ------------------------------- | ------------------------------------------------------ |
| EC2 instances                   | Hosts the Node.js app (Auto Scaling enabled).          |
| Application Load Balancer (ALB) | Distributes incoming HTTP(S) traffic.                  |
| Amazon RDS (external to EB env) | MySQL DB for content and user data.                    |
| S3                              | Stores deployment bundles and logs.                    |
| CloudWatch                      | Monitors CPU, memory, and custom metrics.              |
| Security Groups                 | Only allow ALB to access EC2 and EC2 to access RDS.    |
| VPC                             | Public subnets for ALB, private subnets for EC2 + RDS. |

### Deployment Flow:

1. Dev uploads a new version using `eb deploy` or CI/CD pipeline.
2. Elastic Beanstalk updates the app using **rolling deployment**.
3. ALB continues routing traffic to healthy EC2 instances.
4. Logs are sent to S3/CloudWatch for analysis.

### High Availability:

* Auto Scaling ensures the app runs 2–6 EC2 instances based on CPU usage.
* Load balancer spans across **multiple AZs**.
* Health checks and retries are automatic.

### Benefits:

* No manual provisioning of infrastructure.
* Easy environment cloning for staging vs. production.
* Native support for RDS, logging, monitoring.
* Built-in rollback options.
